{
  "language": "Solidity",
  "sources": {
    "contracts/ManufacturerV1.sol": {
      "content": "//SPDX-License-Identifier: GPL-2.0\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IStation {\n    function mint(address to, uint256 tokenId, string memory _tokenURI, bytes memory _data) external;\n    function totalSupply() external view returns (uint256);\n}\n\ncontract ManufacturerV1 {\n    uint256 public constant SALE_LIMIT = 9000;\n    uint256 public constant TEAM_LIMIT = 1000;\n    uint256 public constant PRICE = 0.08 ether;\n    bytes16 internal constant ALPHABET = '0123456789abcdef';\n\n    address public operator;\n    IERC20 public saleToken;\n    uint256 public sold;\n    uint256 public teamMinted;\n    bool public saleIsActive;\n\n    IStation public station;\n    address public stationLabs;\n\n    constructor(\n        address _operator,\n        IERC20 _saleToken,\n        IStation _station,\n        address _stationLabs\n    ) {\n        operator = _operator;\n        saleToken = _saleToken;\n        station = _station;\n        stationLabs = _stationLabs;\n    }\n\n    function buy(uint256 count) public {\n        require(count > 0, \"Spaceship count cannot be Zero!\");\n        require(count <= SALE_LIMIT - sold, \"Sale out of stock!\");\n        require(saleIsActive, \"Sale is not active!\");\n        \n        uint256 amountDue = count * PRICE;\n        uint256 balanceBefore = saleToken.balanceOf(stationLabs);\n        saleToken.transferFrom(msg.sender, stationLabs, amountDue);\n        uint256 balanceAfter = saleToken.balanceOf(stationLabs);\n        require(balanceAfter - balanceBefore == amountDue);\n\n        for(uint i=0; i<count; i++) {\n            string memory tokenURI = string(abi.encodePacked(\"https://station0x.com/api/\", addressToString(address(station)), \"/\", toString(station.totalSupply()), \".json\"));\n            station.mint(msg.sender, station.totalSupply(), tokenURI, \"\");\n        }\n\n        sold += count;\n    }\n\n    function mintTo(address to, uint256 count) public {\n        require(msg.sender == operator);\n        require(count <= TEAM_LIMIT - teamMinted);\n        require(count > 0);\n\n        for(uint i=0; i<count; i++) {\n            string memory tokenURI = string(abi.encodePacked(\"https://station0x.com/api/\", addressToString(address(station)), \"/\", toString(station.totalSupply()), \".json\"));\n            station.mint(to, station.totalSupply(), tokenURI, \"\");\n        }\n\n        teamMinted += count;\n\n    }\n\n    function setSaleStatus(bool status) public {\n        require(msg.sender == operator);\n        saleIsActive = status;\n    }\n\n    function setOperator(address _newOperator) public {\n        require(msg.sender == operator);\n        operator = _newOperator;\n        emit SetOperator(_newOperator);\n    }\n\n    function addressToString(address addr) internal pure returns (string memory) {\n        uint value = uint256(uint160(addr));\n        uint length = 20;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, 'Strings: hex length insufficient');\n        return string(buffer);\n    }\n    \n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    event SetOperator(address _newOperator);\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}